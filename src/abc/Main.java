package abc;

import hybridseq.HybridForests;
import hybridseq.HybridNetwork;
import hybridseq.HybridNetworkGenerator;
import hybridseq.HybridNetworkParameters;
import hybridseq.Version;
import hybridstats.CompoundStat;
import hybridstats.Forest;
import hybridstats.HybridStats;
import hybridstats.SummaryStatParameters;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.SortedMap;

import org.biojavax.bio.phylo.io.nexus.NexusBlock;
import org.biojavax.bio.phylo.io.nexus.NexusComment;
import org.biojavax.bio.phylo.io.nexus.NexusFile;
import org.biojavax.bio.phylo.io.nexus.NexusFileBuilder;
import org.biojavax.bio.phylo.io.nexus.NexusFileFormat;
import org.biojavax.bio.phylo.io.nexus.NexusObject;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;

import pal.distance.DistanceMatrix;
import palExtensions.IdGroupUtils;

import biojavaExtensions.NexusUtils;

// TODO: ignoring rsThresholds
public class Main {
	public static void main(String[] args) {
		// Set up output stream
		PrintWriter stdout = new PrintWriter(System.out,true); // true -> autoflush
		
		MainConfiguration cfg = new MainConfiguration();
		CmdLineParser parser =  new CmdLineParser(cfg);
		try {
			parser.parseArgument(mdwUtils.Strings.spacifyCommandLine(args));
		} catch (CmdLineException e) {
		    System.err.println(e.getMessage());
		    System.err.println("java -jar myprogram.jar [options...] arguments...");
		    parser.printUsage(System.err);
		    return;
		}
		cfg.parseNexus(stdout);

		// prefixComments will eventually be passed to nexus file output method
		NexusComment[] prefixComments = new NexusComment[2];
		// Display and add to file some versioning information.
		// All added comments must contain the string 'HybridSim' to avoid duplication if output file is subsequently used as input.
		stdout.println("HybridSim: uses PAL 1.5.1, BioJava 1.8.4 and jgrapht 0.9.0 libraries.");
		prefixComments[0]=NexusUtils.newNexusComment("This file was generated by, and can be used as input to, HybridSim");
		String palVersion = pal.util.Version.getVersionString();
		// getVersionString only works if our PAL source was extracted under CVS version control.
		if (palVersion.equals("unknown")) palVersion = "1.5.1"; 
		// I haven't found a way to interrogate BioJava or jgrapht for their version.
		prefixComments[1]=NexusUtils.newNexusComment(String.format("Versions: HybridSim %s, PAL %s, BioJava 1.8.4, jgrapht 0.9.0",Version.VERSION,palVersion));

		NexusFile outputNexusFile = null;
		if (cfg.abc != null) {
			ABCResults abcResults = doABC(cfg, stdout);
			outputNexusFile = makeNewNexusFile(cfg, abcResults, prefixComments);
			String rdataFile;
			if (cfg.outputFile.matches(".*nex")) {
				rdataFile = cfg.outputFile.replace("nex", "csv");
			} else {
				rdataFile = cfg.outputFile + ".csv";
			}
			PrintWriter out;
			try {
				out = new PrintWriter(rdataFile);
				abcResults.outputCommaDelimited(out);
				out.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
			/*
			 * Write the output nexus file
			 */
			try {
				OutputStream outNexus = new FileOutputStream(cfg.outputFile);
				NexusFileFormat.writeStream(outNexus, outputNexusFile);
				outNexus.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}

		} else if (cfg.grid != null) {
			// In desperate need of some abstraction to avoid cut-and-paste of code from above.
			String rdataFile;
			if (cfg.outputFile.matches(".*nex")) {
				rdataFile = cfg.outputFile.replace("nex", "txt");
			} else {
				rdataFile = cfg.outputFile + ".txt";
			}
			PrintWriter out=null;
			try {
				out = new PrintWriter(rdataFile);
				doGrid(cfg.grid,cfg.stats,out);
				out.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}		
		} else {
			doNetwork(cfg,stdout,prefixComments);
		}
	}
	
	private static NexusFile makeNewNexusFile(MainConfiguration cfg, ABCResults abcResults, NexusComment[] prefixComments) {
		NexusFileBuilder outputBuilder = new NexusFileBuilder();
		outputBuilder.startFile();
		NexusFile outputNexusFile = outputBuilder.getNexusFile();

		for (NexusComment comment : prefixComments) {
			outputNexusFile.addObject(comment);
		}
		outputNexusFile.addObject(cfg.abc.getABCBlock(cfg.stats, cfg.params));
		// TODO: Modify HybridSim output block to ignore irrelevant parameters
		outputNexusFile.addObject(cfg.params.getNexusParametersBlock()); // HybridSim parameters block
		outputNexusFile.addObject(abcResults.outputCharactersBlock());
		outputNexusFile.addObject(cfg.targetForest.toTreesBlock(null));
		// Now any (non-auto-generated) comments and unrecognized Nexus blocks in input Nexus file
		// will pass through unmodified to the output Nexus file.
		int deleteComments = 2; // delete two comments if they are first two items and they contain 'HybridSim'.
		// This is to account for the auto-added HybridSeq comments when using an output file as new input.
		@SuppressWarnings("unchecked")
		Iterator<NexusObject>objIter = cfg.nexusFile.objectIterator();
		while (objIter.hasNext()) {
			NexusObject obj = objIter.next();
			if (obj instanceof NexusComment) {
				NexusComment comment = (NexusComment)obj;
				// Pass comment through unless it contains HybridSeq
				// comment.toString does not do what it should, hence extra complication
				if (deleteComments>0 && NexusUtils.toString(comment).contains("HybridSim")) {
					// do not pass comment, decrement count
					deleteComments--;
				} else {
					outputNexusFile.addObject(obj);
					deleteComments=0;
				}
			} else {
				deleteComments=0; // only delete comments prior to first block
				// object is a block
				NexusBlock block = (NexusBlock)obj;
				String name = block.getBlockName();
				if (!name.equalsIgnoreCase("hybridSim") && 
				    !name.equalsIgnoreCase("characters") &&
				    !name.equalsIgnoreCase("ABC") &&
				    !name.equalsIgnoreCase("trees") 
				) {
					/*
					 *  The block is not one which HybridSim needs to replace,
					 *  so just replicate it unchanged
					 *  EXCEPT: BioJava bug: read in an 'unknown' block and write it out
					 *  inserts a newline after the 'begin', so need to fix that,
					 *  via UseableNexusBlock class
					 */
					outputNexusFile.addObject(block);
				}
			}
		}
		return outputNexusFile;
	}
	
	public static void doNetwork(MainConfiguration cfg, PrintWriter out, NexusComment[] prefixComments) {
		HybridNetworkGenerator gen = new HybridNetworkGenerator(cfg.params);
		// Generate a hybrid network from the given parameters:
		HybridNetwork net = gen.generateNetwork(cfg.params.minReticEvents, cfg.params.reduceReticEventsTo);
		// Display a few stats to stdout:
		net.printSummary(out);
	
		// Generate the sets of random trees and use them to create output Nexus file
		HybridForests forests = new HybridForests(net,cfg.params);
		NexusFile outputNexusFile = forests.makeNexusFile(cfg.nexusFile, prefixComments);
		if (cfg.params.reduceReticEventsTo==-1) {
			// Only output distance block if there is no reduction of reticulation events,
			// as deleting reticulation events will make this distance matrix incorrect.
			addDistanceBlock(outputNexusFile,net.getDistanceMatrix());
		} else {
			cfg.nexusFile.addObject(NexusUtils.newNexusComment("Distance block omitted because '"+HybridNetworkParameters.RED_RETIC+"' parameter set"));
		}
		/*
		 * Write the output nexus file
		 */
		try {
			OutputStream outNexus = new FileOutputStream(cfg.outputFile);
			NexusFileFormat.writeStream(outNexus, outputNexusFile);
			outNexus.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private static void addDistanceBlock(NexusFile nexusFile, DistanceMatrix distMat) {
		String[] taxa = IdGroupUtils.toStringArray(distMat);
		double[][] distances = distMat.getClonedDistances();
		nexusFile.addObject(NexusUtils.makeDistancesBlock(taxa, distances));
	}
	
	public static void doGrid(Grid grid, SummaryStatParameters statParams, PrintWriter out) {
		grid.printHeaders(out);
		HybridStats.printRFriendlyHeadings(out, statParams);
		do {
			HybridNetworkParameters params = grid.getParameters();
			HybridNetworkGenerator gen = new HybridNetworkGenerator(params);
			HybridNetwork net = gen.generateNetwork(params.minReticEvents, params.reduceReticEventsTo);
			HybridForests hf = new HybridForests(net,params);
			HybridStats stats = new HybridStats(hf.getCoalescentTrees());
			grid.printCurrentValues(out);
			stats.printRFriendly(out,statParams,false);
		} while (grid.advance());
	}
	
	private static ABCResults doABC(MainConfiguration cfg, PrintWriter out) {
		ABCResults abcResults = new ABCResults();
		RandomHybridParameters hybridParams = cfg.params;
		SummaryStatParameters statParams = cfg.stats;
		Map<String,Double[]> target = calculateTarget(cfg.targetForest, statParams, cfg.abc.getScale(), out);
		int[] statsAccumulator = new int[]{0,0};
		for (int seq=0; seq<cfg.abc.getIterations(); seq++) {
			hybridParams.randomize();
			HybridNetworkGenerator gen = new HybridNetworkGenerator(hybridParams);
			HybridNetwork net = gen.generateNetwork(hybridParams.minReticEvents, hybridParams.reduceReticEventsTo, statsAccumulator);
			HybridForests hf = new HybridForests(net,hybridParams);
			HybridStats stats = new HybridStats(hf.getCoalescentTrees());			
			SortedMap<String,Double> compoundStats = statParams.calculateCompoundStats(stats);
			if (hitTarget(compoundStats,target)) {
				abcResults.add(seq,hybridParams,compoundStats);
				// Progress display goes to terminal (System.out) not output file (out).
				System.out.print('*');
			} else {
				if (seq%10==9) System.out.print((seq+1)/10%10); else System.out.print('.');
			}
			if (seq%100==99) System.out.printf(" [%d]",(seq+1)/100);
			if (seq%50==49) System.out.println();
		}
		float meanAttempts = (float)(statsAccumulator[0])/cfg.abc.getIterations();
		float meanHybrids = (float)(statsAccumulator[1])/cfg.abc.getIterations();		
		System.out.printf("Mean attempts to get sufficient hybridizations = %f\n", meanAttempts);
		System.out.printf("Mean raw hybridizations in successful attempts = %f\n", meanHybrids);
		/*
		 * If meanAttempts is a fair bit bigger than 1, hybridization rate is too low.
		 * If meanHybrids/hybridParams.reduceHybridEventsTo is a fair bit bigger than 1, 
		 * hybridization rate is too high 
		 */
		float hybridRateChangeFactor = meanAttempts*hybridParams.reduceReticEventsTo/meanHybrids;
		if (meanHybrids > 0 && hybridRateChangeFactor > 2) {
			System.out.printf("Hybridization/introgression rates may be too low, try increasing by a factor of about %.0f", 
					hybridRateChangeFactor);
		}
		if (hybridParams.reduceReticEventsTo > 0 && hybridRateChangeFactor < 0.5) {
			System.out.printf("Hybridization/introgression rates may be too high, try decreasing by a factor of about %.0f", 
					1/hybridRateChangeFactor);
		}
		System.out.printf("\nNumber of hits = %d (%f%%)\n",
				abcResults.getNumberHits(),100.0*abcResults.getNumberHits()/cfg.abc.getIterations());
		return abcResults;
	}
	
	// TODO: Abstract type of target and of compoundStats. (Maybe just a local class definition.)
	private static Map<String,Double[]> calculateTarget(Forest forest, SummaryStatParameters statParams, double scale, PrintWriter out) {
		HybridStats stats = new HybridStats(forest);
		out.println("Base stats of given forest:");
		stats.printRFriendly(out, statParams, true);
		HashMap<String,Double[]> target = new HashMap<String,Double[]>();
		Iterator<CompoundStat> iter = statParams.compoundStatIterator();
		while (iter.hasNext()) {
			CompoundStat compStat = iter.next();
			Double[] range = new Double[2];
			compStat.evaluateRange(stats, range, scale);
			target.put(compStat.getName(), range);
			out.printf("Stat '%s' target %f, range %f to %f\n", compStat.getName(), (range[0]+range[1])/2, range[0], range[1]);
		}
		return target;
	}
	
	private static boolean hitTarget(SortedMap<String,Double> compoundStats, Map<String,Double[]> targetRanges) {
		for (Entry<String,Double> stat : compoundStats.entrySet()) {
			Double[] range = targetRanges.get(stat.getKey());
			double value = stat.getValue();
			if (range[0]>value || range[1]<value) return false;
		}
		return true;
	}
}
